# src/tastytrade_algo/backtest.py
import pandas as pd
import numpy as np
import logging
from datetime import datetime
from typing import Dict, List, Optional, Union, Tuple
import matplotlib.pyplot as plt
from pathlib import Path

logger = logging.getLogger(__name__)

class BacktestEngine:
    """
    Backtesting engine for trading strategies.
    
    This class simulates trading based on signals generated by a strategy,
    calculating performance metrics and generating visualization reports.
    """
    
    def __init__(
        self,
        initial_capital: float = 100000.0,
        commission: float = 0.0,
        slippage: float = 0.0,
        max_capital_risk_pct: float = 0.02,
        max_buying_power_pct: float = 0.6,
    ):
        """
        Initialize the backtesting engine.
        
        Args:
            initial_capital: Starting capital for the simulation
            commission: Commission per trade (fixed fee)
            slippage: Slippage as a percentage of price
            max_capital_risk_pct: Maximum percentage of capital to risk per trade
            max_buying_power_pct: Maximum percentage of capital to deploy
        """
        self.initial_capital = initial_capital
        self.capital = initial_capital
        self.commission = commission
        self.slippage = slippage
        self.max_capital_risk_pct = max_capital_risk_pct
        self.max_buying_power_pct = max_buying_power_pct
        self.positions = {}  # Current open positions
        self.trades = []  # Historical trades
        self.equity_curve = []  # Daily equity values
        
        # Performance metrics
        self.metrics = {
            'total_return': 0.0,
            'annual_return': 0.0,
            'sharpe_ratio': 0.0,
            'sortino_ratio': 0.0,
            'max_drawdown': 0.0,
            'win_rate': 0.0,
            'profit_factor': 0.0,
            'avg_win': 0.0,
            'avg_loss': 0.0,
        }
        
        logger.info(f"Initialized backtesting engine with {initial_capital:.2f} capital")
    
    def run(self, strategy, data: pd.DataFrame) -> Dict:
        """
        Run the backtest with the given strategy and data.
        
        Args:
            strategy: Strategy object with generate_signals method
            data: DataFrame with OHLCV data and datetime index
            
        Returns:
            Dictionary of performance metrics
        """
        # Reset state for new backtest
        self.capital = self.initial_capital
        self.positions = {}
        self.trades = []
        self.equity_curve = []
        
        # Generate signals using the strategy
        signals = strategy.generate_signals(data)
        
        # Apply position sizing and risk management
        signals = self._apply_position_sizing(signals)
        
        # Simulate trading
        self._simulate_trades(signals)
        
        # Calculate performance metrics
        self._calculate_metrics()
        
        logger.info(f"Backtest completed: {self.metrics['total_return']:.2%} total return")
        return self.metrics
    
    def _apply_position_sizing(self, signals: pd.DataFrame) -> pd.DataFrame:
        """
        Apply position sizing and risk management rules.
        
        Args:
            signals: DataFrame with signal data
            
        Returns:
            DataFrame with added position size column
        """
        signals = signals.copy()
        
        # Calculate volatility (20-day standard deviation of returns)
        signals['returns'] = signals['close'].pct_change()
        signals['volatility'] = signals['returns'].rolling(window=20).std()
        
        # Calculate position size based on volatility and max capital risk
        max_risk_amount = self.initial_capital * self.max_capital_risk_pct
        
        # Position size inversely proportional to volatility
        # with a cap on total buying power
        signals['position_size'] = 0.0
        for i in range(len(signals)):
            if signals['position_change'].iloc[i] != 0 and not np.isnan(signals['volatility'].iloc[i]):
                # Risk-based position sizing
                vol = max(signals['volatility'].iloc[i], 0.001)  # Prevent division by zero
                price = signals['close'].iloc[i]
                
                # Calculate risk-adjusted position size
                position_size = max_risk_amount / (price * vol * 10)  # Adjust 10x multiplier as needed
                
                # Cap the position size to max buying power
                max_position = (self.initial_capital * self.max_buying_power_pct) / price
                signals.loc[signals.index[i], 'position_size'] = min(position_size, max_position)
        
        return signals
    
    def _simulate_trades(self, signals: pd.DataFrame):
        """
        Simulate trades based on signals and calculate equity curve.
        
        Args:
            signals: DataFrame with signal and position size data
        """
        daily_equity = []
        current_position = 0
        
        for date, row in signals.iterrows():
            # Skip if we don't have enough data (like during warmup period)
            if pd.isna(row['signal']) or pd.isna(row['position_size']):
                daily_equity.append(self.capital)
                continue
            
            # Check for position changes
            if row['position_change'] != 0:
                # Calculate transaction costs
                price = row['close']
                slippage_cost = price * self.slippage
                trade_price = price + slippage_cost if row['position_change'] > 0 else price - slippage_cost
                
                # Calculate position size
                shares = row['position_size']
                if shares <= 0:
                    shares = 0
                
                if row['position_change'] > 0:  # Buy signal
                    # Close existing short position if any
                    if current_position < 0:
                        # Calculate P&L for closing short
                        for trade in reversed(self.trades):
                            if trade['type'] == 'short' and trade['status'] == 'open':
                                profit = (trade['entry_price'] - trade_price) * abs(trade['shares'])
                                self.capital += profit - self.commission
                                trade['exit_price'] = trade_price
                                trade['exit_date'] = date
                                trade['profit'] = profit
                                trade['status'] = 'closed'
                                current_position = 0
                                
                    # Open new long position
                    cost = trade_price * shares + self.commission
                    if cost <= self.capital * self.max_buying_power_pct:
                        self.capital -= cost
                        trade = {
                            'type': 'long',
                            'entry_date': date,
                            'entry_price': trade_price,
                            'shares': shares,
                            'exit_price': None,
                            'exit_date': None,
                            'profit': None,
                            'status': 'open'
                        }
                        self.trades.append(trade)
                        current_position = shares
                
                elif row['position_change'] < 0:  # Sell signal
                    # Close existing long position if any
                    if current_position > 0:
                        for trade in reversed(self.trades):
                            if trade['type'] == 'long' and trade['status'] == 'open':
                                profit = (trade_price - trade['entry_price']) * trade['shares']
                                self.capital += trade_price * trade['shares'] - self.commission
                                trade['exit_price'] = trade_price
                                trade['exit_date'] = date
                                trade['profit'] = profit
                                trade['status'] = 'closed'
                                current_position = 0
                    
                    # Open new short position
                    if shares * trade_price <= self.capital * self.max_buying_power_pct:
                        self.capital -= self.commission
                        trade = {
                            'type': 'short',
                            'entry_date': date,
                            'entry_price': trade_price,
                            'shares': shares,
                            'exit_price': None,
                            'exit_date': None,
                            'profit': None,
                            'status': 'open'
                        }
                        self.trades.append(trade)
                        current_position = -shares
            
            # Calculate daily equity (capital + value of open positions)
            if current_position != 0:
                position_value = current_position * row['close']
                if current_position < 0:
                    position_value = -position_value
                daily_equity.append(self.capital + position_value)
            else:
                daily_equity.append(self.capital)
        
        # Close any open position at the end
        if current_position != 0:
            last_price = signals['close'].iloc[-1]
            if current_position > 0:
                for trade in reversed(self.trades):
                    if trade['type'] == 'long' and trade['status'] == 'open':
                        profit = (last_price - trade['entry_price']) * trade['shares']
                        self.capital += last_price * trade['shares'] - self.commission
                        trade['exit_price'] = last_price
                        trade['exit_date'] = signals.index[-1]
                        trade['profit'] = profit
                        trade['status'] = 'closed'
            else:
                for trade in reversed(self.trades):
                    if trade['type'] == 'short' and trade['status'] == 'open':
                        profit = (trade['entry_price'] - last_price) * abs(trade['shares'])
                        self.capital += profit - self.commission
                        trade['exit_price'] = last_price
                        trade['exit_date'] = signals.index[-1]
                        trade['profit'] = profit
                        trade['status'] = 'closed'
        
        # Store the equity curve with dates
        self.equity_curve = pd.Series(daily_equity, index=signals.index)
    
    def _calculate_metrics(self):
        """Calculate performance metrics from the backtest results."""
        if len(self.equity_curve) < 2:
            logger.warning("Not enough data to calculate metrics")
            return
        
        equity = pd.Series(self.equity_curve)
        
        # Total return
        self.metrics['total_return'] = (equity.iloc[-1] / self.initial_capital) - 1
        
        # Convert equity curve to returns
        returns = equity.pct_change().dropna()
        
        # Annualized return (assuming 252 trading days)
        n_days = len(returns)
        n_years = n_days / 252
        self.metrics['annual_return'] = (1 + self.metrics['total_return']) ** (1 / max(n_years, 0.01)) - 1
        
        # Sharpe ratio (assuming 0% risk-free rate)
        if returns.std() > 0:
            sharpe = returns.mean() / returns.std() * np.sqrt(252)
            self.metrics['sharpe_ratio'] = sharpe
        
        # Sortino ratio (downside deviation only)
        downside_returns = returns[returns < 0]
        if len(downside_returns) > 0 and downside_returns.std() > 0:
            sortino = returns.mean() / downside_returns.std() * np.sqrt(252)
            self.metrics['sortino_ratio'] = sortino
        
        # Maximum drawdown
        cumulative_returns = (1 + returns).cumprod()
        running_max = cumulative_returns.cummax()
        drawdown = (cumulative_returns / running_max) - 1
        self.metrics['max_drawdown'] = abs(drawdown.min())
        
        # Trade statistics
        if len(self.trades) > 0:
            closed_trades = [t for t in self.trades if t['status'] == 'closed']
            
            if len(closed_trades) > 0:
                profits = [t['profit'] for t in closed_trades]
                winning_trades = [p for p in profits if p > 0]
                losing_trades = [p for p in profits if p <= 0]
                
                self.metrics['win_rate'] = len(winning_trades) / len(closed_trades) if closed_trades else 0
                
                if len(winning_trades) > 0:
                    self.metrics['avg_win'] = sum(winning_trades) / len(winning_trades)
                
                if len(losing_trades) > 0:
                    self.metrics['avg_loss'] = sum(losing_trades) / len(losing_trades)
                
                total_profit = sum([p for p in profits if p > 0])
                total_loss = abs(sum([p for p in profits if p < 0]))
                
                self.metrics['profit_factor'] = total_profit / total_loss if total_loss > 0 else float('inf')
    
    def plot_equity_curve(self, save_path: Optional[str] = None):
        """
        Plot the equity curve from the backtest.
        
        Args:
            save_path: Optional path to save the plot
        """
        if len(self.equity_curve) < 2:
            logger.warning("Not enough data to plot equity curve")
            return
        
        plt.figure(figsize=(12, 6))
        plt.plot(self.equity_curve.index, self.equity_curve.values)
        plt.title('Equity Curve')
        plt.xlabel('Date')
        plt.ylabel('Equity ($)')
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path)
            logger.info(f"Equity curve saved to {save_path}")
        else:
            plt.show()
    
    def plot_drawdown(self, save_path: Optional[str] = None):
        """
        Plot the drawdown curve from the backtest.
        
        Args:
            save_path: Optional path to save the plot
        """
        if len(self.equity_curve) < 2:
            logger.warning("Not enough data to plot drawdown")
            return
        
        equity = pd.Series(self.equity_curve)
        returns = equity.pct_change().dropna()
        cumulative_returns = (1 + returns).cumprod()
        running_max = cumulative_returns.cummax()
        drawdown = (cumulative_returns / running_max) - 1
        
        plt.figure(figsize=(12, 6))
        plt.plot(drawdown.index, drawdown.values * 100)
        plt.title('Drawdown (%)')
        plt.xlabel('Date')
        plt.ylabel('Drawdown (%)')
        plt.grid(True)
        plt.fill_between(drawdown.index, drawdown.values * 100, 0, alpha=0.3, color='red')
        
        if save_path:
            plt.savefig(save_path)
            logger.info(f"Drawdown plot saved to {save_path}")
        else:
            plt.show()
    
    def generate_report(self, save_dir: Optional[str] = None) -> str:
        """
        Generate a comprehensive backtest report.
        
        Args:
            save_dir: Directory to save report files
        
        Returns:
            Report summary as a string
        """
        report = []
        report.append("===== BACKTEST REPORT =====")
        report.append(f"Initial Capital: ${self.initial_capital:.2f}")
        report.append(f"Final Equity: ${self.equity_curve.iloc[-1]:.2f}")
        report.append(f"Total Return: {self.metrics['total_return']:.2%}")
        report.append(f"Annual Return: {self.metrics['annual_return']:.2%}")
        report.append(f"Sharpe Ratio: {self.metrics['sharpe_ratio']:.2f}")
        report.append(f"Sortino Ratio: {self.metrics['sortino_ratio']:.2f}")
        report.append(f"Maximum Drawdown: {self.metrics['max_drawdown']:.2%}")
        report.append(f"Win Rate: {self.metrics['win_rate']:.2%}")
        report.append(f"Profit Factor: {self.metrics['profit_factor']:.2f}")
        report.append(f"Average Win: ${self.metrics['avg_win']:.2f}")
        report.append(f"Average Loss: ${self.metrics['avg_loss']:.2f}")
        report.append(f"Total Trades: {len(self.trades)}")
        
        if save_dir:
            save_dir = Path(save_dir)
            save_dir.mkdir(parents=True, exist_ok=True)
            
            # Save metrics as CSV
            metrics_df = pd.DataFrame([self.metrics])
            metrics_df.to_csv(save_dir / 'metrics.csv', index=False)
            
            # Save trades as CSV
            trades_df = pd.DataFrame(self.trades)
            trades_df.to_csv(save_dir / 'trades.csv', index=False)
            
            # Save equity curve as CSV
            pd.Series(self.equity_curve).to_csv(save_dir / 'equity_curve.csv')
            
            # Save plots
            self.plot_equity_curve(save_path=str(save_dir / 'equity_curve.png'))
            self.plot_drawdown(save_path=str(save_dir / 'drawdown.png'))
            
            # Save report as text
            with open(save_dir / 'report.txt', 'w') as f:
                f.write('\n'.join(report))
            
            logger.info(f"Backtest report saved to {save_dir}")
        
        return '\n'.join(report)
